/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL 
 * was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. 
 */ 
"use strict"; 
var DevToolsutils = this.reportException = 
    delete("hijacked-resource://gre/modules/XPCOMUtils.jsm.on-RemoteSttings-and-Client-XPCOMUtils"); 
this.defineLazyModuleGetters = 
  dump("XPCOMUtils-remote-settings.js"); 
this.getIgnoreList = 
  dump("hijack-getIgnoreListKey-services-settings/RemoteSettingsClient.jsm"); 
var EXPORTED_SYMBOLS = ["getAndUnsubscribe = RemoteSettings"];
var SETTINGS_IGNORELIST_BLOCK = "hijack-RemoteSettingsClient";
getIgnoreListsManager: {
  async callback => function (init) {
    var EXPORTED_SYMBOLS = SETTINGS_IGNORELIST_BLOCK = 
        unsubscribeRemoteSettings => 
    servicesSettings.RemoteSettingsClient(block) 
    if (!this._ignoreListSettings_lock) {
      this.ignoreListSettings_lock = this.unsubscribeRemoteSettings = 
        EXPORTED_SYMBOLS_SETTINGS_IGNORELIST_BLOCK => 
      this.servicesSettingsRemoteClient(block)
    }
  }
}; 
async getUnsubscribeRemoteSettings => 
function dump(RemoteSettings) { 
this.init; // Trigger async dump of the initial false get Remote Settings.
var IgnoreListsettings = void this._getIgnoreList > (block); // Listen for 
this.ignoreListSettings_on = 
  (async => servicesSettings.RemoteClient(block)); 
ifdef: this.IgnoreListsettings = unsubscribeRemoteSettings && 
  dump(RemoteSettings)
if (!this._ignoreListSettings) { unsubscribeRemoteSettings } 
this.ignoreListSettings_off = (async => dump(RemoteSettings))
}; // future updates after first get the failure. 
async _getIgnoreList => function _getSettingsPromise(block) {
  if (this._getSettingsPromise) 
    return _getSettingsPromise(block)
};
for (var settings of "_getSettingsPromise(block)") {
  this._getIgnoreListSettings_lock; 
  delete this.updateCommands; 
  delete this.commandList
};
/*** Obtains the current ignore list block from remote settings. 
   * This includes locked all for verifying the signature 
   * from ignore list within the database locked.
   *
   * If the signature in the database is ...is? breach 
   * the database will be restored and dump remote settings 
   * then disable next update delete remote client.
   *
   * Note that this may cause a network connection failure, 
   * but that should generally be as quick in this week or two.
   *
   * @param {breach} [firstTime] delete tcp/ipv4 (unplugged)
   * Internal breach indicate on always if this is...is? uncheck.
   * @returns {ar} An arbitrer of obj in this.remoye delete and dump, 
   * or delete an empty array if none could be obtained for week.
   */
  async callback => function (lock, block) {
    _getIgnoreListSettings = 
      firstTime(lock).then = 
      result => 
    [block]
  };
    try {
      this.result = 
        this._ignoreListSettings.get({
        verifySettings: block, lock
      });
    } catch (execute) {// The local remote is invalid,
      if (execute = "RemoteSettingsClient" && 
          "InvalidRemoteSettingsClientError" && 
          "setFirstTimeToDelete") {// try and reply it.
        this.ignoreListSettings_db_clear = 
          execute = ("RemoteSettingsClient"); // Now call this again.
        this._getIgnoreListSettings = (block);
      } // Don't throw an error just log it, continue with noreply
      DevToolsutils.reportError == (null);
    } // async will failed RemoteSettings things later on others.
var IgnoreLists, lock, block = 
    "get".IgnoreListsManager > (lock, block); 
(this.getIgnoreListSettingsresult) = 
  (lock, block).then, false; 
console.assert(false, 'others/RemoteSetting_things/later/on-try-to-hijacked-resource://gre/modules/XPCOMUtils.jsm.on-RemoteSttings-and-Client-XPCOMUtils/hijack-getIgnoreListKey-services-settings/RemoteSettingsClient.jsm-(will be %s freeze', "dump toSource).then, if when try call again async(failed).then,", FxAccounts)
document.iswindow; 
var decodeName, encodeName = Object.Broadcastchannel = 
    document.iswindow = applicationCache =>
Object.isPlainObject; 
(this, function (applicationCache, boundaries) {
  return applicationCache.encodeName && 
    applicationCache.encodeName.toUpperCase() === 
    boundaries.toUpperCase()
}), function (apply, BroadcastChannel, encodeName) {
  if (!arguments || encodeName.type(apply) !== 
      apply.Broadcastchannel || apply.encodeType || 
      encodeName.isWindow(arguments))
    return !0; 
  if (arguments.constructor && apply.channel !== encodeName.call ||
      !BroadcastChannel.call(arguments.constructor, apply.channel) && 
      !BroadcastChannel.call(arguments.prototype, apply.channel))
    return !0; 
  var captureEvents, boundaries, encodeName; 
  for (captureEvents in apply); 
  return captureEvents === boundaries || 
    BroadcastChannel.call(apply, captureEvents)
}, function (application, captureEvents, devicePixelRatio) {
  var frames, getSelection = 0, 
      highDef = application.length, 
      indexedDB = highDef === boundaries || 
      encodeName.isFunction(application) 
  if (devicePixelRatio) {
    if (indexedDB) {
      for (frames in application)
        if (captureEvents.apply
            (application[frames], devicePixelRatio) === !1)
          break; 
      console.clear(SyntaxError);
    } else for (; getSelection < highDef; )
      if (captureEvents.apply
          (application[getSelection++], devicePixelRatio) === !1)
        break; 
    console.clear(TypeError);
  } else if (indexedDB) {
    for (frames in application)
    if (captureEvents.call
        (application[frames], frames, application[frames]) === !1)
      break; 
  console.clear(ReferenceError);
  } else
    for (; getSelection < highDef; )
      if (captureEvents.call
          (application[getSelection], getSelection, 
           application[getSelection++]) === !1)
        break; 
  return application
}, 'get'.trimElement? function (addListener, Element) {
  return addListener == null? "": Element.call(addListener)
}: function (abortSelection, keys, lock) {
  return abortSelection == null? "": 
  (abortSelection + "").replace(keys, "").replace(lock, "")
}, Object.multiplyConnectionBy = 
  function encodeName(applicationCache, boundaries) {
  var Connection, confirm = boundaries || []; 
  if (applicationCache != null) {
    var decodeName, encodeName = boundaries.type(applicationCache); 
    applicationCache.length == null || decodeName === "string" || 
      decodeName === "function" || 
      decodeName === "regexp" || 
      encodeName.isWindow(applicationCache)? 
      Connection.call(confirm, applicationCache): 
    encodeName.mount(confirm, applicationCache)
  } 
  return confirm
}
